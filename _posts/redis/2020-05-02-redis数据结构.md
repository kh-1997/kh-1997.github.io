---
layout:     post
title:      "Redis数据结构"
subtitle:   "非常水的自我笔记"
date:       2020-04-14 
author:     "KH"
header-img: "img/post-bg-unix-linux.jpg"
catalog: true
tags:
  - redis
---

> This document is not completed and will be updated anytime.

# 一、Redis 字典结构

#### 内部结构

Redis 字典的结构和 Java 中的 HashMap 有点类似，都是存放键值对，在底层都是使用数组加链表（称为一个哈希表）的形式来实现的，但与 HashMap 不同的是，在 Redis 中，它由两个哈希表组成，它的结构大致如下图所示：

![img](https://oscimg.oschina.net/oscnet/1723082939a4b7b6dfaf51fe6e7ddace1c2.jpg)

#### 初始化hashtable

由上图可以看到，它使用两个 hashtable ，姑且称之为 0 号哈希表和 1 号哈希表，每次只会使用 0 号哈希表，那么 1 号哈希表有什么用呢？当哈希表的键值对很多或很少的话，就需要对哈希表进行扩展或缩小，比如哈希表中数组的大小默认为 4 ，如果哈希表中键值对很多，则数组中每项的链表就会很长，而链表查找速度很很慢，不像数组那样根据索引定位，所以为了让哈希表的负载因子（load factor）维持在一个合理的范围内，就需要对哈希表进行扩展或缩小，称为 rehash。

#### 复制扩容

如果哈希表为空，即是第一次添加元素的时候，需要初始化哈希表，哈希表的大小为 4 ，如下所示：

![img](https://oscimg.oschina.net/oscnet/d12f5063abe2c58c262c0b3b208ac0213fe.jpg)

还有一种情况是，如果哈希表的已有的节点和哈希表的大小的比例超过阈值 dict_force_resize_ratio 即 5 的时候，需要对哈希表进行扩展，

扩展的哈希表大小为已使用节点的2倍，如果哈希表的大小为 4 ，已使用节点数量为24， 则 24/4 > 5 ，就需要对哈希表进行扩展，此时哈希表的大小为 24*2 = 48。

## rehash

接下来看下字典的 rehash，字典为什么需要 rehash，随着操作的不断执行， 哈希表保存的键值对会逐渐地增多或者减少， 如果保存的键值很多，哈希表较小，则哈希表中每一项的链表就会很长，而链表的查找速度较慢，所以为了让哈希表的负载因子（load factor）维持在一个合理的范围之内， 当哈希表保存的键值对数量太多或者太少时， 程序需要对哈希表的大小进行相应的扩展或者收缩。

而在 Redis 的字典扩展或缩小的过程中，是一个渐进式的过程，为什么不是一次性进行操作，而是渐进式的方式？因为如果字典较大，在扩展的时候，需要重新申请空间，再把旧字典的值 copy 到新的字典中取，这是一个 O(n) 的操作，很费时，所有，采用的是渐进式的方式，在字典进行扩展的过程中，还可以进行其他的操作，如添加，查找等。

rehash 的过程就是根据 0 号哈希表的已有节点来计算需要扩展的大小，根据该大小创建 1 号哈希表，再把 0 号哈希表的数据慢慢移动到 1 号哈希表上，rehash 指的是重新计算键的哈希值和索引值， 然后将键值对放置到 `ht[1]` 哈希表的指定位置上。当移到完成后，再把 1 号哈希表赋给 0 号哈希表，之后清空 1 号哈希表，为下次 rehash 做准备。

# 二、跳跃表

跳跃表（skiplist）是一种随机化的数据结构，由 **William Pugh** 在论文[《Skip lists: a probabilistic alternative to balanced trees》](https://www.cl.cam.ac.uk/teaching/0506/Algorithms/skiplists.pdf)中提出，是一种可以于平衡树媲美的层次化链表结构——查找、删除、添加等操作都可以在对数期望时间下完成，以下是一个典型的跳跃表例子：

![img](https://upload-images.jianshu.io/upload_images/7896890-65a5b1a2849fb91c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

我们在上一篇中提到了 Redis 的五种基本结构中，有一个叫做 **有序列表 zset** 的数据结构，它类似于 Java 中的 **SortedSet** 和 **HashMap** 的结合体，一方面它是一个 set 保证了内部 value 的唯一性，另一方面又可以给每个 value 赋予一个排序的权重值 score，来达到 **排序** 的目的。

它的内部实现就依赖了一种叫做 **「跳跃列表」** 的数据结构。

## 为什么使用跳跃表

首先，因为 zset 要支持随机的插入和删除，所以它 **不宜使用数组来实现**，关于排序问题，我们也很容易就想到 **红黑树/ 平衡树** 这样的树形结构，为什么 Redis 不使用这样一些结构呢？

1. **性能考虑：** 在高并发的情况下，树形结构需要执行一些类似于 rebalance 这样的可能涉及整棵树的操作，相对来说跳跃表的变化只涉及局部 _(下面详细说)_；
2. **实现考虑：** 在复杂度与红黑树相同的情况下，跳跃表实现起来更简单，看起来也更加直观；

基于以上的一些考虑，Redis 基于 **William Pugh** 的论文做出一些改进后采用了 **跳跃表** 这样的结构。

## 本质是解决查找问题

我们先来看一个普通的链表结构：

![img](https://upload-images.jianshu.io/upload_images/7896890-11b7eebde1779904.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

我们需要这个链表按照 score 值进行排序，这也就意味着，当我们需要添加新的元素时，我们需要定位到插入点，这样才可以继续保证链表是有序的，通常我们会使用 **二分查找法**，但二分查找是有序数组的，链表没办法进行位置定位，我们除了遍历整个找到第一个比给定数据大的节点为止 *（时间复杂度 O(n))* 似乎没有更好的办法。

但假如我们每相邻两个节点之间就增加一个指针，让指针指向下一个节点，如下图：

![img](https://upload-images.jianshu.io/upload_images/7896890-8cae2c261c950b32.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

这样所有新增的指针连成了一个新的链表，但它包含的数据却只有原来的一半 _（图中的为 3，11）_。

现在假设我们想要查找数据时，可以根据这条新的链表查找，如果碰到比待查找数据大的节点时，再回到原来的链表中进行查找，比如，我们想要查找 7，查找的路径则是沿着下图中标注出的红色指针所指向的方向进行的：

![img](https://upload-images.jianshu.io/upload_images/7896890-9c0262c7a85c120e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

这是一个略微极端的例子，但我们仍然可以看到，通过新增加的指针查找，我们不再需要与链表上的每一个节点逐一进行比较，这样改进之后需要比较的节点数大概只有原来的一半。

利用同样的方式，我们可以在新产生的链表上，继续为每两个相邻的节点增加一个指针，从而产生第三层链表：

![img](https://upload-images.jianshu.io/upload_images/7896890-22036e274bedaa5a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

在这个新的三层链表结构中，我们试着 **查找 13**，那么沿着最上层链表首先比较的是 11，发现 11 比 13 小，于是我们就知道只需要到 11 后面继续查找，**从而一下子跳过了 11 前面的所有节点。**

可以想象，当链表足够长，这样的多层链表结构可以帮助我们跳过很多下层节点，从而加快查找的效率。

## 更进一步的跳跃表

**跳跃表 skiplist** 就是受到这种多层链表结构的启发而设计出来的。按照上面生成链表的方式，上面每一层链表的节点个数，是下面一层的节点个数的一半，这样查找过程就非常类似于一个二分查找，使得查找的时间复杂度可以降低到 _O(logn)_。

但是，这种方法在插入数据的时候有很大的问题。新插入一个节点之后，就会打乱上下相邻两层链表上节点个数严格的 2:1 的对应关系。如果要维持这种对应关系，就必须把新插入的节点后面的所有节点 *（也包括新插入的节点）* 重新进行调整，这会让时间复杂度重新蜕化成 _O(n)_。删除数据也有同样的问题。

**skiplist** 为了避免这一问题，它不要求上下相邻两层链表之间的节点个数有严格的对应关系，而是 **为每个节点随机出一个层数(level)**。比如，一个节点随机出的层数是 3，那么就把它链入到第 1 层到第 3 层这三层链表中。为了表达清楚，下图展示了如何通过一步步的插入操作从而形成一个 skiplist 的过程：

![img](https://upload-images.jianshu.io/upload_images/7896890-1e0626c013de095e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

从上面的创建和插入的过程中可以看出，每一个节点的层数（level）是随机出来的，而且新插入一个节点并不会影响到其他节点的层数，因此，**插入操作只需要修改节点前后的指针，而不需要对多个节点都进行调整**，这就降低了插入操作的复杂度。

### 五种基本数据类型

### string

**string 是最常用的一种数据类型，普通的key/value存储都可以归结为string类型，value不仅是string，也可以是数字。其他几种数据类型的构成元素也都是字符串，注意Redis规定字符串的长度不能超过512M**

- 编码 **字符串对象的编码可以是int raw embstr**

  - int编码
    - 保存的是可以用long类型表示的整数值
  - raw编码
    - 保存长度大于44字节的字符串
  - embstr编码
    - 保存长度小于44字节的字符串

  int用来保存整数值，raw用来保存长字符串，embstr用来保存短字符串。embstr编码是用来专门保存短字符串的一种优化编码。

  Redis中对于浮点型也是作为字符串保存的，在需要时再将其转换成浮点数类型

- 编码的转换

  - 当 int 编码保存的值不再是整数，或大小超过了long的范围时，自动转化为raw
  - 对于 embstr 编码，由于 Redis 没有对其编写任何的修改程序（embstr 是只读的），在对embstr对象进行修改时，都会先转化为raw再进行修改，因此，只要是修改embstr对象，修改后的对象一定是raw的，无论是否达到了44个字节。

- 应用场景

  - 因为string类型是二进制安全的，可以用来存放图片，视频等内容。
  - 由于redis的高性能的读写功能，而string类型的value也可以是数字，可以用做计数器（使用INCR，DECR指令）。比如分布式环境中统计系统的在线人数，秒杀等。
  - 除了上面提到的，还有用于SpringSession实现分布式session
  - 分布式系统全局序列号

### list

**list列表,它是简单的字符串列表，你可以添加一个元素到列表的头部，或者尾部**。

- 编码
  - 列表对象的编码可以是ziplist（压缩列表）和linkedlist（双端链表）。
  - 编码转换
    - 同时满足下面两个条件时使用压缩列表：
      - 列表保存元素个数小于512个
      - 每个元素长度小于64字节
    - 不能满足上面两个条件使用linkedlist（双端列表）编码
- 实现数据结构
  - Stack（栈）
    - LPUSH+LPOP
  - Queue（队列）
    - LPUSH + RPOP
  - Blocking MQ（阻塞队列）
    - LPUSH+BRPOP
- 应用场景
  - 实现简单的消息队列
  - 利用LRANGE命令，实现基于Redis的分页功能

### set

**集合对象set是string类型（整数也会转成string类型进行存储）的无序集合。注意集合和列表的区别：集合中的元素是无序的，因此不能通过索引来操作元素；集合中的元素不能有重复。**

- 编码
  - 集合对象的编码可以是intset或者hashtable
    - intset编码的集合对象使用整数集合作为底层实现，集合对象包含的所有元素都被保存在整数集合中。
    - hashtable编码的集合对象使用字典作为底层实现，字典的每个键都是一个字符串对象，这里的每个字符串对象就是一个集合中的元素，而字典的值全部设置为null。**当使用HT编码时，Redis中的集合SET相当于Java中的HashSet，内部的键值对是无序的，唯一的。内部实现相当于一个特殊的字典，字典中所有value都是NULL。**
  - 编码转换
    - 当集合满足下列两个条件时，使用intset编码：
      - 集合对象中的所有元素都是整数
      - 集合对象所有元素数量不超过512
- 应用场景
  - 对于 set 数据类型，由于底层是字典实现的，查找元素特别快，另外set 数据类型不允许重复，利用这两个特性我们可以进行全局去重，比如在用户注册模块，判断用户名是否注册；微信点赞，微信抽奖小程序
  - 另外就是利用交集、并集、差集等操作，可以计算共同喜好，全部的喜好，自己独有的喜好，可能认识的人等功能。

### zset

**和集合对象相比，有序集合对象是有序的。与列表使用索引下表作为排序依据不同，有序集合为每一个元素设置一个分数（score）作为排序依据。**

- 编码

  - 有序集合的编码可以使ziplist或者skiplist

    - ziplist编码的有序集合对象使用压缩列表作为底层实现，每个集合元素使用两个紧挨在一起的压缩列表节点来保存，第一个节点保存元素的成员，第二个节点保存元素的分值。并且压缩列表内的集合元素按分值从小到大的顺序进行排列，小的放置在靠近表头的位置，大的放置在靠近表尾的位置。
    - skiplist编码的依序集合对象使用zset结构作为底层实现，一个zset结构同时包含一个字典和一个跳跃表

    ```
    typedef struct zset{
     //跳跃表
    zskiplist *zsl;
    //字典
    dict *dice;
    }zset
    字典的键保存元素的值，字典的值保存元素的分值，跳跃表节点的object属性保存元素的成员，跳跃表节点的score属性保存元素的分值。这两种数据结构会通过指针来共享相同元素的成员和分值，所以不会产生重复成员和分值，造成内存的浪费。Copy to clipboardErrorCopied
    ```

  - 编码转换

    - 当有序结合对象同时满足以下两个条件时，对象使用ziplist编码，否则使用skiplist编码
      - 保存的元素数量小于128
      - 保存的所有元素长度都小于64字节

- 应用场景

  - 对于 zset 数据类型，有序的集合，可以做范围查找，排行榜应用，取 TOP N 操作等。

### hash

**hash对象的键是一个字符串类型，值是一个键值对集合**

- 编码
  - hash对象的编码可以是ziplist或者hashtable
    - 当使用ziplist，也就是压缩列表作为底层实现时，新增的键值是保存到压缩列表的表尾。
    - hashtable 编码的hash表对象底层使用字典数据结构，哈希对象中的每个键值对都使用一个字典键值对。**Redis中的字典相当于Java里面的HashMap，内部实现也差不多类似，都是通过“数组+链表”的链地址法来解决哈希冲突的，这样的结构吸收了两种不同数据结构的优点。**
  - 编码转换
    - 当同时满足下面两个条件使用ziplist编码，否则使用hashtable编码
      - 列表保存元素个数小于512个
      - 每个元素长度小于64字节
- hash是一个String类型的field和value之间的映射表
- Hash特别适合存储对象
- 所存储的成员较少时数据存储为zipmap,当成员数量增大时会自动转成真正的HashMap，此时encoding为ht

- 优点
  - 同类数据归类整合存储，方便数据管理，比如单个用户的所有商品都放在一个hash表里面。
  - 相比string操作消耗内存cpu更小
- 缺点
  - hash结构的存储消耗要高于单个字符串
  - 过期功能不能使用在field上，只能用在key上
  - redis集群架构不适合大规模使用
- 应用场景
  - 对于 hash 数据类型，value 存放的是键值对，比如可以做单点登录存放用户信息。
  - 存放商品信息，实现购物车