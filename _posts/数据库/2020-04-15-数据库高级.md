---
layout:     post
title:      "数据库优化"
subtitle:   " \"mysql\""
date:       2020-04-29 12:00:00
author:     "KH"
header-img: "img/post-bg-2015.jpg"
catalog: true
tags:
    - 数据库
---

> “Yeah It's on. ”

[跳过废话，直接看技术实现 ](#build) 

------

# Mysql


# 逻辑架构图

   和其他数据库相比，Mysql在存储引擎上采用插件式的存储引擎架构将查询处理和修改更新的系统任务以及数据的存储提取相互分离。

　1）mysql启动以后，初始化模块就从系统配置文件中读取系统参数和命令参数，初始化整个系统，同时存储引擎也会启动；

　　2）初始化结束后，连接管理模块会监听客户端的连接请求，并将连接请求转发给线程管理模块去请求一个连接线程；

　　3）线程模块接到请求后会调用用户模块进行授权检查，通过授权以后会检查是否又空闲线程，如果有取出并与客户端连接，如果没有则新建立建立一个线程与客户端连接；

　　4）mysql请求分为两种，一种是需要命令解析和分发才能执行，另一种可以直接执行；不管哪种，如果开启了日志，那么日志模块会记录日志；

　　5）如果是Query类型的请求，会将控制权交给Query解析器，Query解析器检查是否Select类型，如果是则启动查询缓存模块，如果缓存命中则将缓存数据返回给连接线程模块，连接线程将数据传递到客户端；如果没有缓存或者不是一个可以缓存的查询，此时解析器会进行相应的处理，通过查询分发器给相关的处理模块；

　　6）如果解析器结果是DML/DDL，则交给变更模块；如果是检查、修复的查询交给表维护模块，如果是一条没有被缓存的语句，则交给查询优化器模块。实际上表变更模块又分为若干小模块，例如：insert处理器、delete处理器、update处理器、create处理器，以及alter处理器这些小模块来负责不同的DML和DDL。总之，查询优化器、表变更模块、表维护模块、复制模块、状态模块都是根据命令解析器的结果不同而分发给不同的类型模块，最后和存储引擎进行交互。

　　7）当一条命令执行完毕后，控制权都会还给连接线程模块，在上面各个模块处理过程中都依赖于核心API模块，比如：内存管理、文件I/O，字符串处理等。



![img](https://img2018.cnblogs.com/blog/1485191/201910/1485191-20191008202330054-125227915.png)

连接层

　　最上层是一些客服端和连接服务，包括sock通信和大多数基于客服端/服务端工具实现的类似于tcp/ip的通信，主要完成一些类似于连接处理、授权认证及相关安全的方案，在该层上引入了线程池的概念，为通过认证安全接入的客服端提供线程，同样在该层上可以实现基于SSL的安全的连接，服务器也会为安全接入的每个客户端验证它所具有的操作权限。

服务层

　　第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析以及优化部分内置函数的执行，所有跨存储引擎的功能也在这一层实现，如过程、函数等，服务器会解析查询并创建相应的内部解析树，并对其完成相应的优化如确定查询的顺序是否利用索引，最后生成相应的执行操作。

引擎层

　　存储引擎层，存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API与存储引擎进行通信，不同的存储引擎具有功能不同。

![image-20200320105807282](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200320105807282.png)

存储层

　　数据存储层主要是将数据存储在运行与裸设备的文件系统之上，完成与存储引擎的交互

# 索引优化

**索引是一种数据结构----检索排序**

提高查找效率，可以类比字典

排好序的快速查找数据结构

where  orderBy

索引本身也很大，往往以文件的形式存储在磁盘上

B+树 、哈希索引、full-text全文索引、R-Tree索引

什么时候建立索引	

- ​	主键自动建立索引

- ​	频繁查询

- ​    外键	


什么时候不用建立索引

- ​	数据表记录太少

- ​	频繁更新的字段，增加了索引文件的保存开销

- ​	数据T\F  索引的许多项重复并且平均分配的情况


#### 索引优化

1、单表优化：

范围除外，加入索引

2、双表优化

左连接索引加在右表，右连接索引加在左表

3、总结

- 尽可能减少Join语句中的NestedLoop的循环总次数，小表驱动大表。第一张表总是全表扫描
- 优先优化NestedLoop的内层循环
- 优先Join语句中被驱动表字段已经被索引
- 无法保证被驱动表的Join条件字段被索引且内存资源充足的前提下，不要吝啬JoinBuffer

#### 索引失效

1.全值匹配我最爱

2.最左索引原则，where最左边第一个必须有，不跳过索引中间的列

3.不能再索引列上做任何操作（计算、函数、类型转换）会导致索引失效转向全表扫描

4.不能使用索引中范围条件右边的列

5.尽量使用覆盖索引，少用*，只查索引就能得到结果，不用查原表

6.mysql在使用不等于或者大于小于的时候无法使用索引会导致全表扫描

7.is null 或者is not null  无法使用索引

8.like 以通配符开头%like% mysql索引会失效，加在右边不会失效，使用覆盖索引可以不失效，查询的时候先检查索引中有没有，如果有就不用查询数据表数据了。

9.字符串不加单引号索引失效，因为发生类型转换。

10.少用or，会导致索引失效。



## MYSQL查询优化

- 慢查询的开启并捕获
- explain+慢查询分析
- show profile
- SQL数据库服务器的参数调优

##### 小表驱动大表

##### in 和exist 的区别

- in 先执行子查询，然后返回的数据与主查询匹配
- exist 先执行主查询，将主查询的结果放到子查询中进行验证

##### orderBY优化

mysql支持两种方式的排序，Filesort和Index，Index效率高。它使用MYSQL扫描索引本身完成排序，FileSort方式效率较低。

orderby 满足两种情况，

- Index方式排序：orderby 使用最左前缀原则，使用索引进行排序，和索引一致，避免重复排列。

  如果where使用索引的最左前缀定义为常量，则orderby能使用索引

- filesort：读取文件IO排序，单路排序算法、双路排序算法

  排序降序不一致、丢失最左前缀索引、丢失中间索引、使用非索引排序、最左前缀为范围

提高OrderBy的速度：

1、OrderBy时少使用Select*

2、尝试提高sort_buffer_size

3、尝试提高max_length_for_sort_data



# 数据库锁

### 表锁  

偏向MyISAM，开销小，加锁快，无死锁，锁定粒度大，发生锁冲突的概率最高，并发度最低。

读锁会阻塞写，但是不会阻塞读，写锁会阻塞读和写

读写锁调度是写优先，不适合做写为主表的引擎，因为在写锁后，其他线程不能做任何操作，大量的更新会使得查询很难得到锁，从而造成永远阻塞。

### 行锁

偏向InnoDB,，开销大，加速慢，会出现死锁，锁定粒度小，发生锁冲突的概率最低，并发度也最高，支持事务、行级锁。

事务并发带来的问题：更新丢失（A覆盖B）、脏读（读取已修改但尚未提交的数据  -一致性）、不可重复读（A不能读到A原来数据-隔离性）、幻读（A读取B已新增的数据-隔离性）。

脏读又称无效数据读出。

一个事务读取另外一个事务还没有提交的数据叫脏读。例如：事务T1修改了一行数据，但是还没有提交，这时候事务T2读取了被事务T1修改后的数据，之后事务T1因为某种原因Rollback了，那么事务T2读取的数据就是脏的。解决办法：把数据库的事务隔离级别调整到READ_COMMITTED

不可重复读是指在同一个事务内，两个相同的查询返回了不同的结果。

例如：事务T1读取某一数据，事务T2读取并修改了该数据，T1为了对读取值进行检验而再次读取该数据，便得到了不同的结果。解决办法：把数据库的事务隔离级别调整到REPEATABLE_READ

幻读和不可重复读类似，但是事务二的数据操作仅仅是插入和删除，不是修改数据，读取的记录数量前后不一致。

例如：系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入（注意时插入或者删除，不是修改）了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样。这就叫幻读。解决办法：把数据库的事务隔离级别调整到SERIALIZABLE_READ

事务隔离级别：

- 未提交读 -》脏读、不可重复读、幻读
- 已提交读-》不可重复读、幻读
- 可重复读-》默认-幻读  可以读到原来的数据
- 可序列化-》最高级别

MySql默认的隔离级别为Repeatable Read，因此只会出现幻读的情况。例子：在事务1中，查询User表id为1的是用户否存在，如果不存在则插入一条id为1的数据。在事务1查询结束后，事务2往User表中插入了一条id为1的数据。此时，由于事务1查询到id为1的用户不存在，因此插入1条id为1的数据。但是由于事务2已经插入了1条id为1的数据，因此此时会报主键冲突，

Oracle默认的隔离级别为Read Committed，因此可能出现不可重复度和幻读。同样的条件，你读取过的数据，再次读取出来发现值不一样了。例子：在事务1中，JoonWhee读取了自己的工资为1000，但是此时事务1的操作还并没有完成 ，后面还有1次相同的读取操作。在事务2中，这时财务人员修改了JoonWhee的工资为2000，并提交了事务。在事务1中，JoonWhee再次读取自己的工资时，工资变为了2000 。在一个事务中前后两次读取的结果并不致，导致了不可重复读。

注意事项

- 索引失效会导致行锁变表锁、
- 间隙锁会锁住中间的行
- 如何锁定一行：begin-select...for update
- 查看锁状态：show status like 'innodb_row_lock'

优化建议

- 尽可能所有数据检索通过索引来完成，避免行锁无索引升级为表锁
- 合理设计索引，尽量缩小锁的范围
- 尽可能较少检索条件，避免间隙锁
- 控制事务大小，减少锁定资源量
- 尽可能低级别事务隔离

# 主从复制



### 文稿发布和分享

在您使用 Cmd Markdown 记录，创作，整理，阅读文稿的同时，我们不仅希望它是一个有力的工具，更希望您的思想和知识通过这个平台，连同优质的阅读体验，将他们分享给有相同志趣的人，进而鼓励更多的人来到这里记录分享他们的思想和知识，尝试点击 <i class="icon-share"></i> (Ctrl+Alt+P) 发布这份文档给好友吧！

------

再一次感谢您花费时间阅读这份欢迎稿，点击 <i class="icon-file"></i> (Ctrl+Alt+N) 开始撰写新的文稿吧！祝您在这里记录、阅读、分享愉快！

作者 [@kh-1997][3]     
2020 年 03月08日    