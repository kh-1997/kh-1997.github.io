---
layout: post
title: '递归'
subtitle: '递归'
date: 2020-03-08
categories: program
cover: 'http://on2171g4d.bkt.clouddn.com/jekyll-theme-h2o-postcover.jpg'
tags: leetcode﻿
---

# LeetCode

------

# 全排列

我们理解您需要更便捷更高效的工具记录思想，整理笔记、知识，并将其中承载的价值传播给他人，**Cmd Markdown** 是我们给出的答案 —— 我们为记录思想和分享知识提供更专业的工具。 您可以使用 Cmd Markdown：

> * 整理知识，学习笔记
> * 发布日记，杂文，所见所想
> * 撰写发布技术文稿（代码支持）
> * 撰写发布学术论文（LaTeX 公式支持）

![cmd-markdown-logo](https://www.zybuluo.com/static/img/logo.png)

除了您现在看到的这个 Cmd Markdown 在线版本，您还可以前往以下网址下载：

### [Windows/Mac/Linux 全平台客户端](https://www.zybuluo.com/cmd/)

> 请保留此份 Cmd Markdown 的欢迎稿兼使用说明，如需撰写新稿件，点击顶部工具栏右侧的 <i class="icon-file"></i> **新文稿** 或者使用快捷键 `Ctrl+Alt+N`。

给定一个没有重复数字的序列，返回其所有可能的全排列。

示例:

```
输入: [1,2,3]
输出:
[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]
```

这类题目比较好识别是用回溯。特点是:**需要穷举才能得到答案**。所以我们不能瞎穷举，要有套路的穷举。那套路是啥? 先来看本题的解空间。

到这里你是不是就是很熟悉了,我们的解就是二叉树的叶子节点。我们搜索到叶子节点之后回溯到它的根节点,然后继续搜索。因为二叉树的先序遍历其实就是图的深度优先搜索的一种特殊情况，所以你看到网上很多求全排列的题解写的都是dfs.

那就本题来说，怎么由叶节点回到父节点呢?把最后一个元素移除即可实现。希望大家记住这种求解全部解空间的代码模板.

![img](https://mmbiz.qpic.cn/mmbiz_png/pqveMPic9wJeK3nPffRl1u1ujjt3S5MzpEaZkv8PI2P3lf7upDPvJCeghEMxu3ictMngSWXibLvxmuBRUXUeJZJaA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

```
import java.util.*;
public class Solution {
    ArrayList<ArrayList<Integer>> result = new ArrayList<>();
    public ArrayList<ArrayList<Integer>> permute(int[] num) {
        if(num == null || num.length == 0){
            return result;
        }
        Arrays.sort(num);
        ArrayList<Integer> list = new ArrayList<>();
        backtrack(num,list);
        return result;
    }
    public void backtrack(int[] num,ArrayList<Integer> list){
        if(list.size()==num.length){
            ArrayList<Integer> temp = new ArrayList<>(list);
            result.add(temp);
        }
        for(int i=0;i<num.length;i++){
            if(list.contains(num[i]))
                continue;
            list.add(num[i]);
            backtrack(num,list);
            list.remove(list.size()-1);
        }
    }
}
```
#### 题目描述

给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。

#### 解题思路

```
这道题目我就不做解析了，就是全排列的变种，全排列用backtrack的方法，我们之前已经解析过好几期了，都是一套解题模板，直接记住这种backtrack题目的模板即可快速A掉。
```

#### 实现代码

```
class Solution {
    public List<List<Integer>> combine(int n, int k) {
        List<List<Integer>> res = new ArrayList<>();
        backtrack(res, n, 1, k, new ArrayList<>());
        return res;
    }

    public void backtrack(List<List<Integer>> res, int n, int num, int k, List<Integer> list) {
        if (list.size() == k) {
            res.add(new ArrayList<>(list));
        } else {
            for (int i = num; i <= n; i++) {
                list.add(i);
                backtrack(res, n, i + 1, k, list);
                list.remove(list.size() - 1);
            }
        }
    }
}
```


给定一个可包含重复数字的序列，返回所有不重复的全排列。

示例:

```
输入: [1,1,2]
输出:
[
  [1,1,2],
  [1,2,1],
  [2,1,1]
]
```

前面第46题我们A了一道没有重复的全排列问题。那按照上一题的思路，我们先画一下解空间的二叉树。

注意图中的颜色标识。用一个used数组记录在该轮搜索中是不是被访问过。相邻的两个数相等，而且前一个没有被访问过。那么进行剪枝。最左边搜索完尝试进行搜索，回溯的时候会把used[0] 重置为false。i = 1，used[0] = false, nums[0] == nums[1],这个时候跳过。虚线部分就被剪枝剪掉了。区别于最开始的时候。

![img](https://mmbiz.qpic.cn/mmbiz_png/pqveMPic9wJeZhOotTcbErUbnDKCuXX2bpQmEof6uAbeASkteIx5ptIC4QKujGJaXicZt5pfDhNKbwjZdEAWR4Qw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

![img](https://mmbiz.qpic.cn/mmbiz_png/pqveMPic9wJeZhOotTcbErUbnDKCuXX2bTvuE68MOrR31DICiaysZNzfVeyStco9ibga8W7JwqO3q30nIaYj0KQgA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

```
public class Solution {
    public ArrayList<ArrayList<Integer>> permuteUnique(int[] num) {
        ArrayList<ArrayList<Integer>> result = new ArrayList<>();
        if(num == null || num.length == 0){
            return result;
        }
        Arrays.sort(num);
        int[] used = new int[num.length+1];
        ArrayList<Integer> list = new ArrayList<>();
        backtrack(result,num,list,used);
        return result;
    }
    
    public void backtrack(ArrayList<ArrayList<Integer>>result,int[]num,ArrayList<Integer> list,int[]used){
        if(list.size()==num.length){
            ArrayList<Integer> temp = new ArrayList<>(list);
            result.add(temp);
            return;
        }
        int last = Integer.MAX_VALUE;
        for(int i=0;i<num.length;i++){
            if(used[i]==0&&num[i]!=last){
                used[i] = 1;
                list.add(num[i]);
                backtrack(result,num,list,used);
                last = num[i];
                used[i] = 0;
                list.remove(list.size()-1);
            }
        }
    }
}
```


```

给出集合 [1,2,3,…,n]，其所有元素共有 n! 种排列。

按大小顺序列出所有排列情况，并一一标记，当 n = 3 时, 所有排列如下：

1. "123"
2. "132"
3. "213"
4. "231"
5. "312"
6. "321"
   给定 n 和 k，返回第 k 个排列。

说明：

给定 n 的范围是 [1, 9]。
给定 k 的范围是[1,  n!]。
示例 1:

```
输入: n = 3, k = 3
输出: "213"
```

示例 2:

```
输入: n = 4, k = 9
输出: "2314"
```

这道题还蛮有意思的,我首先一看,这不是backtrack的经典题目吗? backtrack的剪枝可以参看相关文章中有详细的step-by-step的流程.

1. 从小到大把数排好;
2. 用backtrack的方法遍历,每次遍历到一个全排列那么结果,count+1;
3. 遍历到n就return输出
4. 由于用的是backtrack,后面 count > k的情况都直接return掉;

然后用java写了一个版本,还没有剪枝就ac啦.

```


    class Solution {
    	int count = 0;
        List<Integer> finalRes;
        public String getPermutation(int n, int k) {
            int[] nums = new int[n];
            for (int i = 0; i < n; i++) {
                nums[i] = i + 1;
            }
            //第几个解.
            List<Integer> resTemp = new ArrayList<>();
            boolean[] haveSeen = new boolean[n];
            backtrack(nums, k, resTemp, haveSeen);
            StringBuilder res = new StringBuilder();
            for (Integer i : finalRes) {
                res.append(i);
            }
            return res.toString();
        }
    public void backtrack(int[] nums, int k, List<Integer> tempIndex, boolean[] haveSeen) 		{
        if (tempIndex.size() == nums.length) {
            count++;
        }
        if (count == k && tempIndex.size() == nums.length) {
            finalRes = new ArrayList<>(tempIndex);
            return;
        } else if (count < k && tempIndex.size() == nums.length) {
            tempIndex = new ArrayList<>();
        }
        for (int i = 0; i < nums.length; i++) {
            if (haveSeen[i]) {
                continue;
            }
            tempIndex.add(nums[i]);
            haveSeen[i] = true;
            backtrack(nums, k, tempIndex, haveSeen);
            haveSeen[i] = false;
            tempIndex.remove(tempIndex.size() - 1);
        }
    }
    }
```
public class Solution {
    ArrayList<String>list = new ArrayList<String>();
    public String getPermutation(int n, int k) {
        int[] nums = new int[n];
        for(int i=1; i<=n; i++){
            nums[i-1] = i;
        }
        List<List<Integer>> res = new ArrayList<>();
        backtrack(res, new ArrayList<>(), nums,k);
        List<Integer>list = res.get(k-1);
        return list.toString();
    }

    public static void backtrack(List<List<Integer>> res, List<Integer> tempRes, int[] nums,int k) {
        if(res.size()==k){
            return;
        }
        if (tempRes.size() == nums.length) {
            //遍历完了.
            res.add(new ArrayList<>(tempRes));
        } else {
            for (int i = 0; i < nums.length; i++) {
                if (tempRes.contains(nums[i])) {
                    continue;
                }
                tempRes.add(nums[i]);
                backtrack(res, tempRes, nums,k);
                tempRes.remove(tempRes.size()-1);
            }
        }
    }
}
```

## 题目描述

给出一组候选数C和一个目标数T，找出候选数中加起来和等于T的所有组合。

C中的数字在组合中可以被无限次使用

注意：

- 题目中所有的数字（包括目标数T）都是正整数
- 你给出的组合中的数字 (a 1, a 2, … , a k) 要按非递增排序 (ie, a 1 ≤ a 2 ≤ … ≤ a k).
- 结解集中不能包含重复的组合

```
import java.util.*;
public class Solution {
    ArrayList<ArrayList<Integer>>result = new ArrayList<ArrayList<Integer>>();
    public ArrayList<ArrayList<Integer>> combinationSum(int[] num, int target) {
        ArrayList<Integer>list = new ArrayList<Integer>();
        Arrays.sort(num);
        backtrack(list,num,target,0);
        return result;
    }
    public void backtrack(ArrayList<Integer>list,int[]num,int target,int start){
        if(target<0){
            return;
        }
        else if(target==0){
            result.add(new ArrayList<Integer>(list));
        }
        else{
            for(int i=start;i<num.length;i++){
           
                list.add(num[i]);
                backtrack(list,num,target-num[i],i);
                list.remove(list.size()-1);
            }
        }
    }
}
```

## 题目描述

给出一组候选数C和一个目标数T，找出候选数中起来和等于T的所有组合。

C中的每个数字在一个组合中只能使用一次。

注意：

- 题目中所有的数字（包括目标数T）都是正整数
- 组合中的数字 (a 1, a 2, … , a k) 要按非递增排序 (ie, a 1 ≤ a 2 ≤ … ≤ a k).
- 结果中不能包含重复的组合

```
import java.util.*;
public class Solution {
    ArrayList<ArrayList<Integer>>result = new ArrayList<ArrayList<Integer>>();
    public ArrayList<ArrayList<Integer>> combinationSum2(int[] num, int target) {
        ArrayList<Integer>list = new ArrayList<Integer>();
        Arrays.sort(num);
        backtrack(list,num,target,0);
        return result;
    }
    public void backtrack(ArrayList<Integer>list,int[]num,int target,int start){
        if(target<0){
            return;
        }
        else if(target==0){
            result.add(new ArrayList<Integer>(list));
        }
        else{
            for(int i=start;i<num.length;i++){
            if(i>start&&num[i]==num[i-1])  continue;
            list.add(num[i]);
            backtrack(list,num,target-num[i],i+1);
            list.remove(list.size()-1);
            }
        }
    }
}
```



```



### 文稿发布和分享

在您使用 Cmd Markdown 记录，创作，整理，阅读文稿的同时，我们不仅希望它是一个有力的工具，更希望您的思想和知识通过这个平台，连同优质的阅读体验，将他们分享给有相同志趣的人，进而鼓励更多的人来到这里记录分享他们的思想和知识，尝试点击 <i class="icon-share"></i> (Ctrl+Alt+P) 发布这份文档给好友吧！

------

再一次感谢您花费时间阅读这份欢迎稿，点击 <i class="icon-file"></i> (Ctrl+Alt+N) 开始撰写新的文稿吧！祝您在这里记录、阅读、分享愉快！

作者 [@kh-1997][3]     
2020 年 03月08日    
```