---
layout:     post
title:      "设计模式"
subtitle:   " \"组件协作\""
date:       2020-02-29 12:00:00
author:     "KH"
header-img: "img/post-bg-2015.jpg"
catalog: true
tags:
    - 设计模式
    - Meta
---

> “Yeah It's on. ”


# 组件协作

我们理解您需要更便捷更高效的工具记录思想，整理笔记、知识，并将其中承载的价值传播给他人，**Cmd Markdown** 是我们给出的答案 —— 我们为记录思想和分享知识提供更专业的工具。 您可以使用 Cmd Markdown：

> * 整理知识，学习笔记
> * 发布日记，杂文，所见所想
> * 撰写发布技术文稿（代码支持）
> * 撰写发布学术论文（LaTeX 公式支持）

![cmd-markdown-logo](https://www.zybuluo.com/static/img/logo.png)

除了您现在看到的这个 Cmd Markdown 在线版本，您还可以前往以下网址下载：

### [Windows/Mac/Linux 全平台客户端](https://www.zybuluo.com/cmd/)

> 请保留此份 Cmd Markdown 的欢迎稿兼使用说明，如需撰写新稿件，点击顶部工具栏右侧的 <i class="icon-file"></i> **新文稿** 或者使用快捷键 `Ctrl+Alt+N`。

------

## Template Method

使用场景：当要完成某个过程，该过程要执行一系列步骤，这一系列步骤基本相同，但其个别步骤在实现时可能不同，通常考虑用模板方法。

使用原理：父类定义模板，子类提供步骤的实现。

![1583116914(1)](C:\Users\Administrator\Desktop\1583116914(1).png)



`//抽象类，表示豆浆

	public abstract class SoyaMilk {
	//模板方法, make , 模板方法可以做成final , 不让子类去覆盖.
	final void make() {
		
		select(); 
		if（!isPureMilk){
			addCondiments();
		}
		soak();
		beat();
		
	}
	
	//选材料
	void select() {
		System.out.println("第一步：选择好的新鲜黄豆  ");
	}
	
	//添加不同的配料， 抽象方法, 子类具体实现
	abstract void addCondiments();
	
	//浸泡
	void soak() {
		System.out.println("第三步， 黄豆和配料开始浸泡， 需要3小时 ");
	}
	 
	void beat() {
		System.out.println("第四步：黄豆和配料放到豆浆机去打碎  ");
	}
	
	boolean isPureMilk（）{
		return false；
	}
	}
`

抽象类的实现类，自定义模板的部分方法

```
public class RedBeanSoyaMilk extends SoyaMilk {

	@Override
	void addCondiments() {
		// TODO Auto-generated method stub
		System.out.println(" 加入上好的红豆 ");
	}

}

```

启动类

```
public class Client {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		//制作红豆豆浆
		
		System.out.println("----制作红豆豆浆----");
		SoyaMilk redBeanSoyaMilk = new RedBeanSoyaMilk();
		redBeanSoyaMilk.make();
		
		System.out.println("----制作花生豆浆----");
		SoyaMilk peanutSoyaMilk = new PeanutSoyaMilk();
		peanutSoyaMilk.make();
	}

}
```

模板类似于框架，我们可以在抽象类的模板方法中自定义好整个算法的执行框架，将需要用户自定义的方法曝露在子类当中，有用户根据自身的需求重写，然后调用子类中的模板方法执行。

```
public class PureMilk extends SoyaMilk{
	
	@Override
	public void addCondiments(){
	};
	
	@Override
	public void isPureMilk（）{
		return true；
	}

}
```

## Spring中的模板模式

##### spring IOC 初始化容器的时候用到

 ![image-20200302111731215](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200302111731215.png)

##### 类关系图

![image-20200302111826249](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200302111826249.png)

注意：

- 钩子方法是指在父类中定义一个空方法，不做任何事，在子类在可以视情况决定要不要实现它。

- 一般模板方法加上final，防止子类重写
- 抽象类不能实例化




## Observer Pattern

1. 使用场景：在基于事件的UI框架中常用的设计模式，也是MVC模式的一个重要组成部分。

2. 使用原理：对目标对象进行监听，当目标对象执行目标行为的时候，向观察者发送通知：目标对象持有观察者的接口集合，事件发生时，就便历通知所有观察者的方法。
3. 设计原则：

- 合成复用原则：多用组合、聚合，少用继承
- 依赖倒转原则：将变化进行隔离，使目标对象依赖于抽象观察者而不是具体的观察者，具体观察者依赖于抽象观察者
- 开闭原则：增加新的观察者，在已有代码上进行扩展

![image-20200302144348722](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200302144348722.png)



```
//观察者接口，有观察者来实现
public interface Observer {

	public void update(float temperature, float pressure, float humidity);
}

```

	public class CurrentConditions implements Observer {
	// 温度，气压，湿度
	private float temperature;
	private float pressure;
	private float humidity;
	
	// 更新 天气情况，是由 WeatherData 来调用，使用推送模式
	public void update(float temperature, float pressure, float humidity) {
		this.temperature = temperature;
		this.pressure = pressure;
		this.humidity = humidity;
		display();
	}
	
	// 显示
	public void display() {
		System.out.println("***Today mTemperature: " + temperature + "***");
		System.out.println("***Today mPressure: " + pressure + "***");
		System.out.println("***Today mHumidity: " + humidity + "***");
	}
}

```
//接口, 让WeatherData 来实现 
public interface Subject {
	
	public void registerObserver(Observer o);
	public void removeObserver(Observer o);
	public void notifyObservers();
}
```

```
/**
 * 类是核心
 * 1. 包含最新的天气情况信息 
 * 2. 含有 观察者集合，使用ArrayList管理
 * 3. 当数据有更新时，就主动的调用   ArrayList, 通知所有的（接入方）就看到最新的信息
 * @author Administrator
 *
 */
public class WeatherData implements Subject {
	private float temperatrue;
	private float pressure;
	private float humidity;
	//观察者集合
	private ArrayList<Observer> observers;
	
	//加入新的第三方

	public WeatherData() {
		observers = new ArrayList<Observer>();
	}

	public float getTemperature() {
		return temperatrue;
	}

	public float getPressure() {
		return pressure;
	}

	public float getHumidity() {
		return humidity;
	}

	public void dataChange() {
		//调用 接入方的 update
		
		notifyObservers();
	}

	//当数据有更新时，就调用 setData
	public void setData(float temperature, float pressure, float humidity) {
		this.temperatrue = temperature;
		this.pressure = pressure;
		this.humidity = humidity;
		//调用dataChange， 将最新的信息 推送给 接入方 currentConditions
		dataChange();
	}

	//注册一个观察者
	@Override
	public void registerObserver(Observer o) {
		// TODO Auto-generated method stub
		observers.add(o);
	}

	//移除一个观察者
	@Override
	public void removeObserver(Observer o) {
		// TODO Auto-generated method stub
		if(observers.contains(o)) {
			observers.remove(o);
		}
	}

	//遍历所有的观察者，并通知
	@Override
	public void notifyObservers() {
		// TODO Auto-generated method stub
		for(int i = 0; i < observers.size(); i++) {
			observers.get(i).update(this.temperatrue, this.pressure, this.humidity);
		}
	}
}

```

```
public class Client {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		//创建一个WeatherData
		WeatherData weatherData = new WeatherData();
		
		//创建观察者
		CurrentConditions currentConditions = new CurrentConditions();
		BaiduSite baiduSite = new BaiduSite();
		
		//注册到weatherData
		weatherData.registerObserver(currentConditions);
		weatherData.registerObserver(baiduSite);
		
		//测试
		System.out.println("通知各个注册的观察者, 看看信息");
		weatherData.setData(10f, 100f, 30.3f);
		
		weatherData.removeObserver(currentConditions);
		//测试
		System.out.println();
		System.out.println("通知各个注册的观察者, 看看信息");
		weatherData.setData(10f, 100f, 30.3f);
	}

}

```
## Strategy Method

1. 使用场景：Strategy模式提供了用条件判断语句以外的另一种选择，消除条件判断语句，就是在解耦合。含有许多条件判断语句的代码，并且if的情况变化不能确定的时候通常都需要Strategy模式

2. 使用原理：一方定义策略，将策略基类聚合到另一方类中，在另一方的具体实现类中进行不同策略调用。
3. 设计原则：

- 合成复用原则：多用组合、聚合，少用继承
- 依赖倒转原则：将变化进行隔离，使高层依赖于不变化的低层接口，具体实现依赖于接口
- 开闭原则：增加新的功能，在已有代码上进行扩展，而不修改原来的if...else代码块

![image-20200302124355109](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200302124355109.png)

分别封装策略接口，实现算法族，超类里面放策略接口对象，在子类里面设定行为对象。原则就是分离变化部分，封装接口，基于接口编程，让策略的变化独立于算法的使用者。

## JDK-Arrays中的策略模式

##### JDK的Arrays的Comparator使用了策略模式

 ![image-20200302124802484](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20200302124802484.png)

##### 




### 文稿发布和分享

在您使用 Cmd Markdown 记录，创作，整理，阅读文稿的同时，我们不仅希望它是一个有力的工具，更希望您的思想和知识通过这个平台，连同优质的阅读体验，将他们分享给有相同志趣的人，进而鼓励更多的人来到这里记录分享他们的思想和知识，尝试点击 <i class="icon-share"></i> (Ctrl+Alt+P) 发布这份文档给好友吧！

------

再一次感谢您花费时间阅读这份欢迎稿，点击 <i class="icon-file"></i> (Ctrl+Alt+N) 开始撰写新的文稿吧！祝您在这里记录、阅读、分享愉快！

作者 [@kh-1997][3]     
2020 年 03月21日    